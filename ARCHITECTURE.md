# Application Architecture

This document outlines the architecture of the Trendsetter Pro application, which follows a modern, decoupled, two-tier architecture to enhance scalability, reliability, and security. The previous three-tier architecture involving a standalone crawler service has been simplified for better performance and easier maintenance.

## The Two-Tier Architecture

The application now consists of two primary components that work together asynchronously.

### 1. Frontend & API Gateway (The Next.js Application)

-   **Role:** The primary user interface and the secure entry point for long-running backend tasks.
-   **Technology:** Next.js, React, Tailwind CSS, ShadCN UI.
-   **Key Features:**
    -   **UI:** A comprehensive dashboard with specialized "AI Agent" modules for various tasks like content generation, trend discovery, and competitor analysis.
    -   **API Gateway (`/api/analyze`):** Instead of calling backend functions directly from the frontend, the app uses a local API route that acts as a **secure proxy**. The frontend component calls a Server Action, which in turn calls this API route. The route validates the request, logs it, and then forwards it to the deployed Firebase Function. This prevents the function's URL from being exposed on the client side.
-   **Benefits:**
    -   **Security:** The actual backend function URLs and other sensitive details are never exposed to the client's browser.
    -   **Centralization:** The API Gateway is the perfect place to add future cross-cutting concerns like user authentication checks, rate limiting, or advanced logging without modifying the frontend client or the backend function.
    -   **Observability:** The gateway implements structured, JSON-based logging with unique request IDs to trace operations from the user's initial click.

### 2. Backend AI Agents (Firebase Functions & Firestore)

-   **Role:** An event-driven system for handling heavy, long-running background tasks like AI analysis and web crawling.
-   **Technology:** Firebase Functions (Node.js), Firestore, Genkit AI, Playwright.
-   **Key Features:**
    -   **`analyze` (HTTP Triggered Function):** A lightweight HTTP-triggered function that receives a request from the API Gateway. It runs the competitor analysis flow, which includes crawling a URL and running an AI analysis. It leverages a Firestore-based cache to return results for identical requests instantly.
    -   **Integrated Crawler Tool:** The web crawling logic, which uses Playwright, is now a **Genkit Tool** that runs directly within the Firebase Functions environment. This eliminates the need for a separate, standalone crawler service, reducing deployment complexity and removing a network hop. The browser instance is intelligently managed and reused across function invocations for optimal performance.
    -   **Firestore for Caching & Drafts:** The `ai_cache` collection stores results of expensive AI operations. The `articles` collection stores drafts and published content generated by the AI.
-   **Benefits:**
    -   **Responsiveness:** By caching expensive operations, the app feels much faster for repeated requests.
    -   **Resilience:** Heavy-lifting is done in the backend, isolated from the user-facing API.
    -   **Scalability:** The system can handle a large influx of requests.
    -   **Simplified Operations:** With one fewer service to deploy, manage, and monitor, the overall operational burden is significantly reduced.

## End-to-End Workflow: Competitor Analysis Example

This is how the components work together to fulfill a user request:

1.  **User (Browser):** Clicks "Analyze Competitor" for a URL on the `/dashboard/competitor-analyzer` page.
2.  **Next.js App (Server Action):** The component calls a Server Action (`handleCompetitorAnalysis`).
3.  **API Gateway (`/api/analyze`):** The Server Action sends a `POST` request to its own API Gateway. The gateway logs the request and securely calls the deployed `analyze` Firebase Function.
4.  **`analyze` Function:**
    *   Checks the `ai_cache` collection in Firestore for a recent result for this URL.
    *   **Cache Hit:** If a valid result exists, it's returned immediately.
    *   **Cache Miss:**
        *   It calls the `competitorAnalyzerFlow` Genkit flow.
        *   The Genkit flow invokes its integrated `crawlUrlTool`, which uses Playwright within the same function environment to crawl the URL and return clean text.
        *   The AI flow analyzes the text to generate the competitor report.
        *   The function saves the result to the `ai_cache` collection with a 24-hour expiration.
        *   The result is returned to the API gateway, which forwards it back to the browser.
5.  **User (Browser):** The `CompetitorAnalyzerClient` component receives the data and displays the report card.
